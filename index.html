<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Triad Trainer</title>
<style>
  :root { --bg:#111; --fg:#f7f7f7; --muted:#9aa0a6; --accent:#3ba55c; --on:#3ba55c; }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  .wrap { display:flex; flex-direction:column; height:100%; gap:.75rem; }
  header, footer { padding: 0.5rem 0.75rem; }
  header { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; justify-content:center; }
  button, input {
    font-size:1rem; padding:.55rem .85rem; border-radius:.6rem; border:1px solid #333; background:#1b1b1b; color:var(--fg);
    -webkit-tap-highlight-color: transparent;
  }
  button.primary { background:var(--accent); border-color:#2a8f4b; color:#fff; }
  button.toggled { outline: 2px solid var(--accent); }
  input[type="number"]{ width:7ch; text-align:center; }
  .flex { display:flex; gap:.5rem; align-items:center; }
  main { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:0 .75rem 1rem; gap:0.75rem; user-select:none; -webkit-user-select:none; }
  #card { font-weight:700; letter-spacing:.02em; line-height:1.05; }
  #chord { font-size: min(18vw, 150px); }
  #detail { font-size: min(5.5vw, 32px); color:var(--muted); margin-top:.35rem; }
  footer { text-align:center; color:var(--muted); font-size:.9rem; }
  .hint { color:var(--muted); font-size:.85rem; }

  /* Keyboard viewport (always shows EXACTLY 2 octaves worth of white-key width) */
  #kbdWrap { width:100%; max-width:900px; display:none; }
  #kbdViewport {
    width:100%;
    height: 160px; /* responsive height below */
    overflow:hidden;              /* no scrollbars; we auto-center programmatically */
    border-radius:.5rem; border:1px solid #333; background:#0d0d0d;
    touch-action:manipulation;
  }
  @media (max-width:480px){
    #kbdViewport { height: 130px; }
    #chord { font-size: min(20vw, 120px); }
    #detail { font-size: min(6vw, 26px); }
  }

  /* Keys */
  .wkey { fill:#fdfdfd; stroke:#333; stroke-width:2; }
  .bkey { fill:#1a1a1a; stroke:#333; stroke-width:2; }
  .lit  { fill:#cfead6; }          /* lit white key */
  .litb { fill:#2e5136; }          /* lit black key */
  .bass { stroke: var(--on); stroke-width:5; } /* bass emphasis */
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="flex">
      <button id="modeManual" class="toggled">Manual</button>
      <button id="modeTimed">Timed</button>
    </div>
    <div class="flex" id="timedControls" style="display:none">
      <label for="seconds">Every</label>
      <input id="seconds" type="number" min="1" step="1" value="4" />
      <span>sec</span>
      <button id="start" class="primary">Start</button>
      <button id="stop">Stop</button>
      <span class="hint" id="countdown"></span>
    </div>
    <button id="toggleKbd">Keyboard</button>
    <button id="next">Next</button>
  </header>

  <main id="tapArea" title="Tap anywhere to advance (Manual mode)">
    <div id="card">
      <div id="chord">—</div>
      <div id="detail">Tap “Next” or the screen</div>
    </div>

    <!-- Auto-scaled keyboard: we compute key sizes so 14 white keys == viewport width -->
    <div id="kbdWrap" aria-hidden="true">
      <div id="kbdViewport">
        <svg id="kbd" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet" role="img" aria-label="Piano keyboard"></svg>
      </div>
      <div class="hint" style="text-align:center;margin-top:.25rem;">Shows exactly two octaves, centered on the bass note.</div>
    </div>
  </main>

  <footer>
    Tap anywhere to advance in <strong>Manual</strong> mode. In <strong>Timed</strong> mode, press <em>Start</em>.
  </footer>
</div>

<script>
(() => {
  // === Data & deck ===
  const NAMES = ["C","C♯","D","D♯","E","F","F♯","G","G♯","A","A♯","B"];
  const QUALS = [
    { name:"Major",  suffix:"",   third:4, fifth:7 },
    { name:"Minor",  suffix:"m",  third:3, fifth:7 },
    { name:"Diminished", suffix:"dim", third:3, fifth:6 }
  ];
  const INVERSIONS = [
    { name:"Root position", bass:"root" },
    { name:"1st inversion", bass:"third" },
    { name:"2nd inversion", bass:"fifth" },
  ];
  const noteName = i => NAMES[(i+12)%12];
  const mod = (n,m)=>((n%m)+m)%m;

  function buildDeck() {
    const deck = [];
    for (let r=0; r<12; r++) {
      for (const q of QUALS) {
        const root = r, third = r + q.third, fifth = r + q.fifth;
        for (const inv of INVERSIONS) {
          const chordLabel = noteName(root) + q.suffix;
          let slash = "", bassIdx = root;
          if (inv.bass === "third") { slash = "/" + noteName(third); bassIdx = third; }
          else if (inv.bass === "fifth") { slash = "/" + noteName(fifth); bassIdx = fifth; }
          deck.push({
            display: slash ? (chordLabel + slash) : chordLabel,
            detail: `${q.name} – ${inv.name}`,
            pcs: [mod(root,12), mod(third,12), mod(fifth,12)],
            bassPc: mod(bassIdx,12)
          });
        }
      }
    }
    return deck;
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

  // === Keyboard (responsive: fits exactly two octaves to viewport width) ===
  const svg = document.getElementById('kbd');
  const viewport = document.getElementById('kbdViewport');

  // dynamic sizes computed from viewport width so 14 white keys == viewport width
  let whiteW = 30, whiteH = 200, blackW = 20, blackH = 120;
  const startMidi = 48;   // C3
  const octaves = 5;      // draw 5 octaves internally for centering room

  function isBlackPc(pc){ return [1,3,6,8,10].includes(pc); }
  const whiteOrder = [0,2,4,5,7,9,11];
  const blackMap = { 1: {dx: 0.7}, 3: {dx: 1.65}, 6: {dx: 0.7}, 8: {dx: 1.65}, 10:{dx: 2.6} }; // in whiteW units

  function sizeKeyboard(){
    // 14 white keys should equal viewport clientWidth
    const w = Math.max(200, viewport.clientWidth);
    whiteW = w / 14;
    whiteH = Math.round(Math.max(120, viewport.clientHeight || 160));
    blackW = Math.round(whiteW * 0.66);
    blackH = Math.round(whiteH * 0.62);
  }

  function buildKeyboard(){
    svg.innerHTML = "";  // clear
    // total white keys in 5 octaves:
    const totalWhite = 7 * octaves;
    const totalW = totalWhite * whiteW;
    svg.setAttribute('viewBox', `0 0 ${totalW} ${whiteH}`);
    svg.setAttribute('width', totalW);
    svg.setAttribute('height', whiteH);

    // White keys
    let x = 0, midi = startMidi;
    for (let o=0; o<octaves; o++){
      for (const pc of whiteOrder){
        const m = midi + pc;
        const r = rect(x, 0, whiteW, whiteH, 'wkey', `m${m}`);
        svg.appendChild(r);
        x += whiteW;
      }
      midi += 12;
    }
    // Black keys
    midi = startMidi;
    for (let o=0; o<octaves; o++){
      const x_oct = o * 7 * whiteW;
      placeBlack(x_oct + blackMap[1].dx*whiteW, midi+1);
      placeBlack(x_oct + blackMap[3].dx*whiteW, midi+3);
      placeBlack(x_oct + (3+blackMap[6].dx)*whiteW, midi+6);
      placeBlack(x_oct + (3+blackMap[8].dx)*whiteW, midi+8);
      placeBlack(x_oct + (3+blackMap[10].dx)*whiteW, midi+10);
      midi += 12;
    }
  }

  function rect(x,y,w,h,cls,id){
    const el=document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x); el.setAttribute('y',y);
    el.setAttribute('width',w); el.setAttribute('height',h);
    el.setAttribute('class',cls); if(id) el.setAttribute('id',id);
    return el;
  }
  function placeBlack(x, midi){
    const r = rect(x - blackW/2 + whiteW/2, 0, blackW, blackH, 'bkey', `m${midi}`);
    svg.appendChild(r);
  }
  function clearKeys(){
    svg.querySelectorAll('.wkey,.bkey').forEach(k=>k.classList.remove('lit','litb','bass'));
  }
  function lightMidi(m, isBass=false){
    const el = document.getElementById(`m${m}`);
    if (!el) return;
    const pc = ((m%12)+12)%12;
    el.classList.add(isBlackPc(pc) ? 'litb' : 'lit');
    if (isBass) el.classList.add('bass');
  }

  function centerOnMidi(m){
    const el = document.getElementById(`m${m}`);
    if (!el) return;
    const box = el.getBBox();
    const center = box.x + box.width/2;
    // Because we sized so 14 whites == viewport width, this keeps exactly two octaves in view
    viewport.scrollLeft = Math.max(0, center - viewport.clientWidth/2);
  }

  // === Voicing around center (keep bass near middle area, others within next octave) ===
  function midiUpToPc(baseMidi, targetPc){
    for (let mm=baseMidi; mm<baseMidi+12; mm++) if (mm%12===targetPc) return mm;
    return baseMidi;
  }
  function voiceAroundCenter(pcs, bassPc){
    const centerC = 72; // C5
    let bass = midiUpToPc(centerC, bassPc);
    const out = [bass];
    for (const pc of pcs){
      if (pc === bassPc) continue;
      let m = midiUpToPc(centerC, pc);
      while (m <= bass) m += 12;
      if (m > bass + 12) m -= 12;
      out.push(m);
    }
    out.sort((a,b)=>a-b);
    const bi = out.indexOf(bass); if (bi>0){ out.splice(bi,1); out.unshift(bass); }
    return out;
  }

  // === App state / UI ===
  let deck = shuffle(buildDeck());
  let idx = -1;

  const modeManualBtn = document.getElementById('modeManual');
  const modeTimedBtn  = document.getElementById('modeTimed');
  const timedControls = document.getElementById('timedControls');
  const nextBtn       = document.getElementById('next');
  const startBtn      = document.getElementById('start');
  const stopBtn       = document.getElementById('stop');
  const secInput      = document.getElementById('seconds');
  const tapArea       = document.getElementById('tapArea');
  const chordEl       = document.getElementById('chord');
  const detailEl      = document.getElementById('detail');
  const countdownEl   = document.getElementById('countdown');
  const toggleKbdBtn  = document.getElementById('toggleKbd');
  const kbdWrap       = document.getElementById('kbdWrap');

  let mode = 'manual';
  let timer = null;
  let countdownTimer = null;
  let remaining = 0;
  let kbdVisible = false;

  function renderChord(card){
    chordEl.textContent = card.display;
    detailEl.textContent = card.detail;

    if (!kbdVisible) return;

    clearKeys();
    const midiNotes = voiceAroundCenter(card.pcs, card.bassPc);
    midiNotes.forEach((m,i)=> lightMidi(m, i===0));
    centerOnMidi(midiNotes[0]);
  }

  function nextCard() {
    idx = (idx + 1) % deck.length;
    if (idx === 0) deck = shuffle(deck);
    renderChord(deck[idx]);
  }

  function setMode(newMode) {
    mode = newMode;
    if (mode === 'manual') {
      modeManualBtn.classList.add('toggled');
      modeTimedBtn.classList.remove('toggled');
      timedControls.style.display = 'none';
      stopTimer();
    } else {
      modeTimedBtn.classList.add('toggled');
      modeManualBtn.classList.remove('toggled');
      timedControls.style.display = 'flex';
    }
  }

  function startTimer() {
    const s = Math.max(1, parseInt(secInput.value || "4", 10));
    remaining = s; updateCountdown();
    nextCard();
    stopTimer();
    timer = setInterval(() => { nextCard(); remaining = s; }, s*1000);
    clearInterval(countdownTimer);
    countdownTimer = setInterval(() => { remaining = Math.max(0, remaining - 1); updateCountdown(); }, 1000);
  }
  function stopTimer() {
    if (timer) clearInterval(timer), timer = null;
    if (countdownTimer) clearInterval(countdownTimer), countdownTimer = null;
    countdownEl.textContent = "";
  }
  function updateCountdown(){ countdownEl.textContent = timer ? `Next in ${remaining}s` : ''; }

  function toggleKeyboard() {
    kbdVisible = !kbdVisible;
    if (kbdVisible) {
      toggleKbdBtn.classList.add('toggled');
      kbdWrap.style.display = 'block';
      // Build and render to current card
      sizeKeyboard(); buildKeyboard();
      if (idx >= 0) renderChord(deck[idx]);
    } else {
      toggleKbdBtn.classList.remove('toggled');
      kbdWrap.style.display = 'none';
    }
  }

  // Recompute sizes on rotate/resize for iPhone friendliness
  window.addEventListener('resize', () => {
    if (!kbdVisible) return;
    sizeKeyboard(); buildKeyboard();
    if (idx >= 0) renderChord(deck[idx]);
  });

  // Events
  nextBtn.addEventListener('click', nextCard);
  tapArea.addEventListener('click', () => { if (mode==='manual') nextCard(); });
  modeManualBtn.addEventListener('click', () => setMode('manual'));
  modeTimedBtn .addEventListener('click', () => setMode('timed'));
  startBtn.addEventListener('click', () => { setMode('timed'); startTimer(); });
  stopBtn .addEventListener('click', stopTimer);
  secInput.addEventListener('change', () => { if (timer) startTimer(); });
  toggleKbdBtn.addEventListener('click', toggleKeyboard);

  // First card
  nextCard();
})();
</script>
</body>
</html>