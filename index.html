<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Triad Trainer</title>
<style>
  :root { --bg:#111; --fg:#f7f7f7; --muted:#9aa0a6; --accent:#3ba55c; --on:#3ba55c; }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  .wrap { display:flex; flex-direction:column; height:100%; gap:.75rem; }
  header, footer { padding: 0.5rem 0.75rem; }
  header { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; justify-content:center; }
  button, input {
    font-size:1rem; padding:.55rem .85rem; border-radius:.6rem; border:1px solid #333; background:#1b1b1b; color:var(--fg);
    -webkit-tap-highlight-color: transparent;
  }
  button.primary { background:var(--accent); border-color:#2a8f4b; color:#fff; }
  button.toggled { outline: 2px solid var(--accent); }
  .chip { padding:.4rem .7rem; border-radius:999px; }
  .chip.on { background:#202b20; outline:2px solid var(--accent); }
  .group { display:flex; gap:.4rem; align-items:center; flex-wrap:wrap; }
  .label { color:var(--muted); font-size:.9rem; margin-right:.25rem; }
  input[type="number"]{ width:7ch; text-align:center; }
  main { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:0 .75rem 1rem; gap:0.75rem; user-select:none; -webkit-user-select:none; }
  #card { font-weight:700; letter-spacing:.02em; line-height:1.05; }
  #chord { font-size: min(18vw, 150px); }
  #detail { font-size: min(5.5vw, 32px); color:var(--muted); margin-top:.35rem; }
  footer { text-align:center; color:var(--muted); font-size:.9rem; }
  .hint { color:var(--muted); font-size:.85rem; }

  /* Keyboard viewport (always shows EXACTLY 2 octaves wide) */
  #kbdWrap { width:100%; max-width:900px; display:none; }
  #kbdViewport {
    width:100%; height: 160px; overflow:hidden;
    border-radius:.5rem; border:1px solid #333; background:#0d0d0d;
    touch-action:manipulation;
  }
  @media (max-width:480px){
    #kbdViewport { height: 130px; }
    #chord { font-size: min(20vw, 120px); }
    #detail { font-size: min(6vw, 26px); }
  }

  /* Keys */
  .wkey { fill:#fdfdfd; stroke:#333; stroke-width:2; }
  .bkey { fill:#1a1a1a; stroke:#333; stroke-width:2; }
  .lit  { fill:#cfead6; }   /* lit white key */
  .litb { fill:#8fb698; }   /* lit black key */
  .bass { stroke: var(--on); stroke-width:5; } /* bass emphasis */
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="group">
      <button id="modeManual" class="toggled">Manual</button>
      <button id="modeTimed">Timed</button>
      <div class="group" id="timedControls" style="display:none">
        <span class="label">Every</span>
        <input id="seconds" type="number" min="1" step="1" value="4" />
        <span class="label">sec</span>
        <button id="start" class="primary">Start</button>
        <button id="stop">Stop</button>
        <span class="hint" id="countdown"></span>
      </div>
    </div>

    <div class="group">
      <span class="label">Qualities:</span>
      <button id="qMaj" class="chip on">Major</button>
      <button id="qMin" class="chip on">Minor</button>
      <button id="qDim" class="chip on">Diminished</button>
    </div>

    <div class="group">
      <span class="label">Inversions:</span>
      <button id="toggleInv" class="chip on" title="On = include 1st & 2nd inversions">On</button>
    </div>

    <div class="group">
      <button id="toggleKbd">Keyboard</button>
      <button id="next">Next</button>
    </div>
  </header>

  <main id="tapArea" title="Tap anywhere to advance (Manual mode)">
    <div id="card">
      <div id="chord">—</div>
      <div id="detail">Enable at least one quality</div>
    </div>

    <!-- Auto-scaled keyboard: 14 white keys == viewport width -->
    <div id="kbdWrap" aria-hidden="true">
      <div id="kbdViewport">
        <svg id="kbd" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet" role="img" aria-label="Piano keyboard"></svg>
      </div>
      <div class="hint" style="text-align:center;margin-top:.25rem;">Shows two octaves, centered on the bass note.</div>
    </div>
  </main>

  <footer>Tap anywhere to advance in <strong>Manual</strong> mode. In <strong>Timed</strong> mode, press <em>Start</em>.</footer>
</div>

<script>
(() => {
  // === Data ===
  const NAMES = ["C","C♯","D","D♯","E","F","F♯","G","G♯","A","A♯","B"];
  const QUALS_ALL = [
    { key:"maj", name:"Major",  suffix:"",   third:4, fifth:7 },
    { key:"min", name:"Minor",  suffix:"m",  third:3, fifth:7 },
    { key:"dim", name:"Diminished", suffix:"dim", third:3, fifth:6 }
  ];
  const INVS_ALL = [
    { key:"root", label:"Root position", bass:"root" },
    { key:"1st",  label:"1st inversion", bass:"third" },
    { key:"2nd",  label:"2nd inversion", bass:"fifth" },
  ];
  const noteName = i => NAMES[(i+12)%12];
  const mod = (n,m)=>((n%m)+m)%m;

  // === Settings (UI state) ===
  const settings = { maj:true, min:true, dim:true, inversions:true };

  // === Build deck per settings ===
  function currentQuals(){
    return QUALS_ALL.filter(q => settings[q.key]);
  }
  function currentInvs(){
    if (!settings.inversions) return INVS_ALL.slice(0,1); // root only
    return INVS_ALL;
  }

  function buildDeck() {
    const deck = [];
    const quals = currentQuals();
    const invs = currentInvs();
    for (let r=0; r<12; r++) {
      for (const q of quals) {
        const root = r, third = r + q.third, fifth = r + q.fifth;
        for (const inv of invs) {
          const chordLabel = noteName(root) + q.suffix;
          let slash = "", bassIdx = root;
          if (inv.bass === "third") { slash = "/" + noteName(third); bassIdx = third; }
          else if (inv.bass === "fifth") { slash = "/" + noteName(fifth); bassIdx = fifth; }
          deck.push({
            display: slash ? (chordLabel + slash) : chordLabel,
            detail: `${q.name} – ${inv.label}`,
            pcs: [mod(root,12), mod(third,12), mod(fifth,12)],
            bassPc: mod(bassIdx,12)
          });
        }
      }
    }
    return deck;
  }

  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

  // === Keyboard (responsive two octaves) ===
  const svg = document.getElementById('kbd');
  const viewport = document.getElementById('kbdViewport');
  let whiteW = 30, whiteH = 200, blackW = 20, blackH = 120;
  const startMidi = 48;   // C3
  const octaves = 5;      // draw 5 internally for centering wiggle room
  const whiteOrder = [0,2,4,5,7,9,11];
  const blackMap = { 1: 0.7, 3: 1.65, 6: 0.7, 8: 1.65, 10: 2.6 }; // in whiteW units
  const isBlackPc = pc => [1,3,6,8,10].includes(pc);

  function sizeKeyboard(){
    const w = Math.max(200, viewport.clientWidth);
    whiteW = w / 14;                // 14 white keys = 2 octaves
    whiteH = Math.round(Math.max(120, viewport.clientHeight || 160));
    blackW = Math.round(whiteW * 0.66);
    blackH = Math.round(whiteH * 0.62);
  }
  function rect(x,y,w,h,cls,id){
    const el=document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x); el.setAttribute('y',y);
    el.setAttribute('width',w); el.setAttribute('height',h);
    el.setAttribute('class',cls); if(id) el.setAttribute('id',id);
    return el;
  }
  function placeBlack(x, midi){
    const r = rect(x - blackW/2 + whiteW/2, 0, blackW, blackH, 'bkey', `m${midi}`);
    svg.appendChild(r);
  }
  function buildKeyboard(){
    svg.innerHTML = "";
    const totalWhite = 7 * octaves;
    const totalW = totalWhite * whiteW;
    svg.setAttribute('viewBox', `0 0 ${totalW} ${whiteH}`);
    svg.setAttribute('width', totalW);
    svg.setAttribute('height', whiteH);

    let x = 0, midi = startMidi;
    for (let o=0; o<octaves; o++){
      for (const pc of whiteOrder){
        const m = midi + pc;
        svg.appendChild(rect(x,0,whiteW,whiteH,'wkey',`m${m}`));
        x += whiteW;
      }
      midi += 12;
    }
    midi = startMidi;
    for (let o=0; o<octaves; o++){
      const x_oct = o * 7 * whiteW;
      placeBlack(x_oct + blackMap[1]*whiteW, midi+1);
      placeBlack(x_oct + blackMap[3]*whiteW, midi+3);
      placeBlack(x_oct + (3+blackMap[6])*whiteW, midi+6);
      placeBlack(x_oct + (3+blackMap[8])*whiteW, midi+8);
      placeBlack(x_oct + (3+blackMap[10])*whiteW, midi+10);
      midi += 12;
    }
  }
  function clearKeys(){ svg.querySelectorAll('.wkey,.bkey').forEach(k=>k.classList.remove('lit','litb','bass')); }
  function lightMidi(m, isBass=false){
    const el = document.getElementById(`m${m}`); if (!el) return;
    const pc = ((m%12)+12)%12;
    el.classList.add(isBlackPc(pc) ? 'litb' : 'lit');
    if (isBass) el.classList.add('bass');
  }
  function centerOnMidi(m){
    const el = document.getElementById(`m${m}`); if (!el) return;
    const box = el.getBBox();
    const center = box.x + box.width/2;
    viewport.scrollLeft = Math.max(0, center - viewport.clientWidth/2);
  }

  // Voicing around C5
  function midiUpToPc(baseMidi, targetPc){
    for (let mm=baseMidi; mm<baseMidi+12; mm++) if (mm%12===targetPc) return mm;
    return baseMidi;
  }
  function voiceAroundCenter(pcs, bassPc){
    const centerC = 72; // C5
    let bass = midiUpToPc(centerC, bassPc);
    const out = [bass];
    for (const pc of pcs){
      if (pc === bassPc) continue;
      let m = midiUpToPc(centerC, pc);
      while (m <= bass) m += 12;
      if (m > bass + 12) m -= 12;
      out.push(m);
    }
    out.sort((a,b)=>a-b);
    const bi = out.indexOf(bass); if (bi>0){ out.splice(bi,1); out.unshift(bass); }
    return out;
  }

  // === App state ===
  let deck = []; let idx = -1;

  // UI elements
  const modeManualBtn = document.getElementById('modeManual');
  const modeTimedBtn  = document.getElementById('modeTimed');
  const timedControls = document.getElementById('timedControls');
  const nextBtn       = document.getElementById('next');
  const startBtn      = document.getElementById('start');
  const stopBtn       = document.getElementById('stop');
  const secInput      = document.getElementById('seconds');
  const tapArea       = document.getElementById('tapArea');
  const chordEl       = document.getElementById('chord');
  const detailEl      = document.getElementById('detail');
  const countdownEl   = document.getElementById('countdown');
  const toggleKbdBtn  = document.getElementById('toggleKbd');
  const kbdWrap       = document.getElementById('kbdWrap');

  const qMajBtn = document.getElementById('qMaj');
  const qMinBtn = document.getElementById('qMin');
  const qDimBtn = document.getElementById('qDim');
  const toggleInvBtn = document.getElementById('toggleInv');

  let mode = 'manual';
  let timer = null;
  let countdownTimer = null;
  let remaining = 0;
  let kbdVisible = false;

  function refreshDeckAndShow(){
    deck = shuffle(buildDeck());
    idx = -1;
    if (deck.length === 0){
      chordEl.textContent = "—";
      detailEl.textContent = "Enable at least one quality";
      clearKeys();
      return;
    }
    nextCard(); // show first
  }

  function renderChord(card){
    chordEl.textContent = card.display;
    detailEl.textContent = card.detail;
    if (!kbdVisible) return;
    clearKeys();
    const midiNotes = voiceAroundCenter(card.pcs, card.bassPc);
    midiNotes.forEach((m,i)=> lightMidi(m, i===0));
    centerOnMidi(midiNotes[0]);
  }

  function nextCard() {
    if (deck.length === 0) return;
    idx = (idx + 1) % deck.length;
    if (idx === 0) deck = shuffle(deck);
    renderChord(deck[idx]);
  }

  // Mode & timer
  function setMode(newMode) {
    mode = newMode;
    if (mode === 'manual') {
      modeManualBtn.classList.add('toggled');
      modeTimedBtn.classList.remove('toggled');
      timedControls.style.display = 'none';
      stopTimer();
    } else {
      modeTimedBtn.classList.add('toggled');
      modeManualBtn.classList.remove('toggled');
      timedControls.style.display = 'flex';
    }
  }
  function startTimer() {
    if (deck.length === 0) return;
    const s = Math.max(1, parseInt(secInput.value || "4", 10));
    remaining = s; updateCountdown();
    nextCard();
    stopTimer();
    timer = setInterval(() => { nextCard(); remaining = s; }, s*1000);
    clearInterval(countdownTimer);
    countdownTimer = setInterval(() => { remaining = Math.max(0, remaining - 1); updateCountdown(); }, 1000);
  }
  function stopTimer() {
    if (timer) clearInterval(timer), timer = null;
    if (countdownTimer) clearInterval(countdownTimer), countdownTimer = null;
    countdownEl.textContent = "";
  }
  function updateCountdown(){ countdownEl.textContent = timer ? `Next in ${remaining}s` : ''; }

  // Keyboard toggle
  function toggleKeyboard() {
    kbdVisible = !kbdVisible;
    if (kbdVisible) {
      toggleKbdBtn.classList.add('toggled');
      kbdWrap.style.display = 'block';
      sizeKeyboard(); buildKeyboard();
      if (idx >= 0 && deck.length) renderChord(deck[idx]);
    } else {
      toggleKbdBtn.classList.remove('toggled');
      kbdWrap.style.display = 'none';
    }
  }

  // Quality toggles
  function toggleChip(el, key){
    const on = !el.classList.contains('on');
    el.classList.toggle('on', on);
    settings[key] = on;
    refreshDeckAndShow();
  }
  qMajBtn.addEventListener('click', ()=>toggleChip(qMajBtn,'maj'));
  qMinBtn.addEventListener('click', ()=>toggleChip(qMinBtn,'min'));
  qDimBtn.addEventListener('click', ()=>toggleChip(qDimBtn,'dim'));

  // Inversions toggle
  toggleInvBtn.addEventListener('click', () => {
    const on = !toggleInvBtn.classList.contains('on');
    toggleInvBtn.classList.toggle('on', on);
    toggleInvBtn.textContent = on ? 'On' : 'Off';
    settings.inversions = on;
    refreshDeckAndShow();
  });

  // Resize handling
  window.addEventListener('resize', () => {
    if (!kbdVisible) return;
    sizeKeyboard(); buildKeyboard();
    if (idx >= 0 && deck.length) renderChord(deck[idx]);
  });

  // Events
  document.getElementById('next').addEventListener('click', nextCard);
  document.getElementById('modeManual').addEventListener('click', () => setMode('manual'));
  document.getElementById('modeTimed').addEventListener('click', () => setMode('timed'));
  document.getElementById('start').addEventListener('click', () => { setMode('timed'); startTimer(); });
  document.getElementById('stop').addEventListener('click', stopTimer);
  document.getElementById('seconds').addEventListener('change', () => { if (timer) startTimer(); });
  document.getElementById('toggleKbd').addEventListener('click', toggleKeyboard);
  document.getElementById('tapArea').addEventListener('click', () => { if (mode==='manual') nextCard(); });

  // Init
  sizeKeyboard(); buildKeyboard(); // prebuild (hidden) so first show is instant
  refreshDeckAndShow();
})();
</script>
</body>
</html>